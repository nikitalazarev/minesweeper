{"ast":null,"code":"import { Component } from 'react';\nimport './App.css';\n\nconst _ = require('underscore');\n\nclass App extends Component {\n  constructor(props) {\n    super(props);\n    this.state = void 0;\n    this.state = {\n      cellsMount: {\n        row: 8,\n        col: 10\n      },\n      minesMount: 10,\n      result: {\n        isWin: null,\n        open: false\n      },\n      winTitles: ['YOU WIN!', 'GAME OVER']\n    };\n    this.openCell = this.openCell.bind(this);\n    this.markCell = this.markCell.bind(this);\n    this.restart = this.restart.bind(this);\n  }\n\n  openCell(pos) {\n    const updatedCells = this.state.cells.map(el => el);\n\n    if (updatedCells[pos.row][pos.col].state !== 'mark') {\n      updatedCells[pos.row][pos.col].state = 'open';\n\n      if (updatedCells[pos.row][pos.col].isMine) {\n        updatedCells.map(el => {\n          el.map(cell => {\n            if (cell.isMine) {\n              cell.state = 'open mine inactive';\n            } else {\n              cell.state = \"\".concat(cell.state, \" inactive\");\n            }\n          });\n        });\n      } else {\n        const openedEmpty = [];\n\n        for (let i = 0; i < updatedCells.length; i++) {\n          for (let j = 0; j < updatedCells[i].length; j++) {\n            if (updatedCells[i][j].cellsAround && updatedCells[i][j].minesAround === 0 && updatedCells[i][j].state === 'open' && !openedEmpty.includes(updatedCells[i][j].id)) {\n              updatedCells[i][j].cellsAround.map(cell => {\n                cell.state = 'open';\n              });\n              openedEmpty.push(updatedCells[i][j].id);\n              i = 0;\n              j = 0;\n            }\n          }\n        }\n      }\n\n      this.setState({\n        cells: updatedCells\n      });\n      this.checkResult('open', updatedCells);\n    }\n  }\n\n  markCell(pos) {\n    const updatedCells = this.state.cells.map(el => el);\n\n    if (updatedCells[pos.row][pos.col].state === 'close') {\n      updatedCells[pos.row][pos.col].state = 'mark';\n    } else if (updatedCells[pos.row][pos.col].state === 'mark') {\n      updatedCells[pos.row][pos.col].state = 'close';\n    }\n\n    this.setState({\n      cells: updatedCells\n    });\n    this.checkResult('mark', updatedCells);\n  }\n\n  checkResult(action, updatedCells) {\n    if (action === 'mark') {\n      let rightMarked = 0;\n      let wrongMarked = 0;\n      updatedCells.map(el => {\n        el.map(cell => {\n          if (cell.state === 'mark') {\n            if (cell.isMine) {\n              rightMarked++;\n            } else {\n              wrongMarked++;\n            }\n          }\n        });\n      });\n      const isWin = rightMarked === this.state.minesMount && !wrongMarked ? true : null;\n\n      if (isWin) {\n        updatedCells.map(el => {\n          el.map(cell => {\n            cell.state = cell.state + ' inactive';\n          });\n        });\n      }\n\n      if (isWin) {\n        this.setState({\n          cells: updatedCells,\n          result: {\n            isWin,\n            open: true\n          }\n        });\n      }\n    }\n\n    if (action === 'open') {\n      let isWin = null;\n      updatedCells.map(el => {\n        el.map(cell => {\n          if (cell.state === 'open mine inactive') {\n            isWin = false;\n          }\n        });\n      });\n\n      if (isWin === false) {\n        this.setState({\n          result: {\n            isWin,\n            open: true\n          }\n        });\n      }\n    }\n  }\n\n  restart() {\n    const _this$state = this.state,\n          minesMount = _this$state.minesMount,\n          cellsMount = _this$state.cellsMount;\n\n    const arr = _.shuffle(_.range(cellsMount.row * cellsMount.col));\n\n    const minesCells = _.range(minesMount).map(el => arr[el]); // let cells:Cell[][] = [];\n\n\n    let cells = new Array();\n    let cellCounter = 0;\n\n    for (let i = 0; i < cellsMount.row; i++) {\n      // cells.push([]);\n      cells[i] = new Array();\n\n      for (let j = 0; j < cellsMount.col; j++) {\n        const cell = {\n          id: cellCounter,\n          pos: {\n            row: i,\n            col: j\n          },\n          isMine: minesCells.includes(cellCounter),\n          cellsAround: null,\n          minesAround: null,\n          state: 'close'\n        };\n        cells[i].push(cell);\n        cellCounter++;\n      }\n    }\n\n    cells.map(el => {\n      el.map(cell => {\n        if (!cell.isMine) {\n          let koef = -1;\n          let minesCounter = 0;\n          cell.cellsAround = [];\n\n          for (let i = 0; i < 3; i++) {\n            if (cells[cell.pos.row - 1] && cells[cell.pos.row - 1][cell.pos.col + koef]) {\n              cell.cellsAround.push(cells[cell.pos.row - 1][cell.pos.col + koef]);\n\n              if (cells[cell.pos.row - 1][cell.pos.col + koef].isMine) {\n                minesCounter++;\n              }\n            }\n\n            if (cells[cell.pos.row + 1] && cells[cell.pos.row + 1][cell.pos.col + koef]) {\n              cell.cellsAround.push(cells[cell.pos.row + 1] && cells[cell.pos.row + 1][cell.pos.col + koef]);\n\n              if (cells[cell.pos.row + 1][cell.pos.col + koef].isMine) {\n                minesCounter++;\n              }\n            }\n\n            koef++;\n          }\n\n          koef = -1;\n\n          for (let i = 0; i < 2; i++) {\n            if (cells[cell.pos.row][cell.pos.col + koef]) {\n              cell.cellsAround.push(cells[cell.pos.row][cell.pos.col + koef]);\n\n              if (cells[cell.pos.row][cell.pos.col + koef].isMine) {\n                minesCounter++;\n              }\n            }\n\n            koef = 1;\n          }\n\n          cell.minesAround = minesCounter;\n        }\n      });\n    });\n    this.setState({\n      cells: cells,\n      result: {\n        isWin: this.state.result.isWin,\n        open: false\n      }\n    });\n  }\n\n  componentDidMount() {\n    const _this$state2 = this.state,\n          minesMount = _this$state2.minesMount,\n          cellsMount = _this$state2.cellsMount;\n\n    const arr = _.shuffle(_.range(cellsMount.row * cellsMount.col));\n\n    const minesCells = _.range(minesMount).map(el => arr[el]); // let cells:Cell[][] = [];\n\n\n    let cells = new Array();\n    let cellCounter = 0;\n\n    for (let i = 0; i < cellsMount.row; i++) {\n      // cells.push([]);\n      cells[i] = new Array();\n\n      for (let j = 0; j < cellsMount.col; j++) {\n        const cell = {\n          id: cellCounter,\n          pos: {\n            row: i,\n            col: j\n          },\n          isMine: minesCells.includes(cellCounter),\n          cellsAround: null,\n          minesAround: null,\n          state: 'close'\n        };\n        cells[i].push(cell);\n        cellCounter++;\n      }\n    }\n\n    cells.map(el => {\n      el.map(cell => {\n        if (!cell.isMine) {\n          let koef = -1;\n          let minesCounter = 0;\n          cell.cellsAround = [];\n\n          for (let i = 0; i < 3; i++) {\n            if (cells[cell.pos.row - 1] && cells[cell.pos.row - 1][cell.pos.col + koef]) {\n              cell.cellsAround.push(cells[cell.pos.row - 1][cell.pos.col + koef]);\n\n              if (cells[cell.pos.row - 1][cell.pos.col + koef].isMine) {\n                minesCounter++;\n              }\n            }\n\n            if (cells[cell.pos.row + 1] && cells[cell.pos.row + 1][cell.pos.col + koef]) {\n              cell.cellsAround.push(cells[cell.pos.row + 1] && cells[cell.pos.row + 1][cell.pos.col + koef]);\n\n              if (cells[cell.pos.row + 1][cell.pos.col + koef].isMine) {\n                minesCounter++;\n              }\n            }\n\n            koef++;\n          }\n\n          koef = -1;\n\n          for (let i = 0; i < 2; i++) {\n            if (cells[cell.pos.row][cell.pos.col + koef]) {\n              cell.cellsAround.push(cells[cell.pos.row][cell.pos.col + koef]);\n\n              if (cells[cell.pos.row][cell.pos.col + koef].isMine) {\n                minesCounter++;\n              }\n            }\n\n            koef = 1;\n          }\n\n          cell.minesAround = minesCounter;\n        }\n      });\n    });\n    this.setState({\n      cells: cells\n    });\n  }\n\n}\n\nexport default App;","map":{"version":3,"sources":["/home/nick/minesweeper_ts/src/App.tsx"],"names":["Component","_","require","App","constructor","props","state","cellsMount","row","col","minesMount","result","isWin","open","winTitles","openCell","bind","markCell","restart","pos","updatedCells","cells","map","el","isMine","cell","openedEmpty","i","length","j","cellsAround","minesAround","includes","id","push","setState","checkResult","action","rightMarked","wrongMarked","arr","shuffle","range","minesCells","Array","cellCounter","koef","minesCounter","componentDidMount"],"mappings":"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","sourcesContent":["import React, {Component} from 'react';\nimport logo from './logo.svg';\nimport './App.css';\nconst _:any = require('underscore')\n\ninterface Pos{\n  row: number,\n  col: number\n}\ninterface Cell{ \n  id: number,\n  pos: {\n    row: number,\n    col: number\n  },\n  isMine: boolean,\n  cellsAround: null | Cell[],\n  minesAround: null | number,\n  state: string,\n}\n\ninterface State{\n  cellsMount: {\n    row: number,\n    col: number,\n  },\n  minesMount: number,\n  result: {isWin: null, open: boolean},\n  winTitles: [string, string],\n  cells: Cell[][]\n}\n\nclass App extends Component {\n  state: State;\n  constructor(props:any) {\n    super(props);\n    this.state = {\n      cellsMount: {\n        row: 8,\n        col: 10,\n      },\n      minesMount: 10,\n      result: {isWin: null, open: false},\n      winTitles: ['YOU WIN!', 'GAME OVER'],\n    };\n\n    this.openCell = this.openCell.bind(this)\n    this.markCell = this.markCell.bind(this)\n    this.restart = this.restart.bind(this)\n  }\n\n  openCell(pos: Pos):void {\n    const updatedCells = this.state.cells.map( (el: Cell[]) => el);\n\n    if(updatedCells[pos.row][pos.col].state !== 'mark'){\n      updatedCells[pos.row][pos.col].state = 'open';\n\n      if(updatedCells[pos.row][pos.col].isMine){\n        updatedCells.map( (el: Cell[]) => {\n          el.map( (cell: Cell) => {\n            if(cell.isMine){\n              cell.state = 'open mine inactive'\n            }else{\n              cell.state = `${cell.state} inactive`\n            }\n          })\n        })\n      }else{\n        const openedEmpty:Cell[]  = [];\n        for(let i = 0; i < updatedCells.length; i++){\n          for(let j = 0; j < updatedCells[i].length; j++){\n            if(updatedCells[i][j].cellsAround \n              && updatedCells[i][j].minesAround === 0 \n              && updatedCells[i][j].state === 'open' \n              && !openedEmpty.includes(updatedCells[i][j].id)){\n                updatedCells[i][j].cellsAround.map( (cell: Cell) => {\n                  cell.state = 'open';\n                })\n                openedEmpty.push(updatedCells[i][j].id);\n                i = 0;\n                j = 0;\n            }\n          }\n        }\n      }\n\n      this.setState({cells: updatedCells});\n      this.checkResult('open',updatedCells);\n    }\n  }\n\n  markCell(pos: Pos):void {\n    const updatedCells = this.state.cells.map( (el: Cell[]) => el);\n\n    if(updatedCells[pos.row][pos.col].state === 'close'){\n      updatedCells[pos.row][pos.col].state = 'mark';\n    }else if(updatedCells[pos.row][pos.col].state === 'mark'){\n      updatedCells[pos.row][pos.col].state = 'close'\n    }\n\n    this.setState({cells: updatedCells});\n    this.checkResult('mark',updatedCells);\n  }\n\n  checkResult(action: string, updatedCells: Cell[][]):void {\n    if(action === 'mark'){\n      let rightMarked = 0;\n      let wrongMarked = 0;\n      updatedCells.map( (el: Cell[]) => {\n        el.map( (cell: Cell) => {\n          if(cell.state === 'mark'){\n            if(cell.isMine){\n              rightMarked++;\n            }else{\n              wrongMarked++;\n            }\n          }\n        })\n      });\n\n      const isWin:boolean|null = (rightMarked === this.state.minesMount && !wrongMarked) ? true : null\n\n      if(isWin){\n        updatedCells.map( (el: Cell[]) => {\n          el.map( (cell: Cell) => {\n            cell.state = cell.state + ' inactive'\n          })\n        })\n      }\n\n      if(isWin){\n        this.setState({cells: updatedCells, result: {isWin, open: true}})\n      }\n    }\n    if(action === 'open'){\n      let isWin = null;\n      updatedCells.map( (el: Cell[]) => {\n          el.map( (cell: Cell) => {\n            if(cell.state === 'open mine inactive'){\n              isWin = false\n            }\n          })\n      })\n\n      if(isWin === false){\n        this.setState({result: {isWin, open: true}})\n      }\n    }\n  }\n\n  restart():void {\n    const {\n      minesMount,\n      cellsMount,\n    } = this.state;\n\n    \n    const arr:number[] = _.shuffle(_.range(cellsMount.row * cellsMount.col));\n    const minesCells:number[] = _.range(minesMount).map( (el:number) => arr[el] );\n\n    // let cells:Cell[][] = [];\n    let cells:Cell[][] = new Array<Array<Cell>>();\n    let cellCounter:number = 0;\n    for(let i = 0; i < cellsMount.row; i++){\n      // cells.push([]);\n      cells[i] = new Array<Cell>();\n      for(let j = 0; j < cellsMount.col; j++){\n        const cell:Cell = {\n          id: cellCounter,\n          pos: {\n            row: i,\n            col: j\n          },\n          isMine: minesCells.includes(cellCounter),\n          cellsAround: null,\n          minesAround: null,\n          state: 'close',\n        }\n        cells[i].push(cell);\n        cellCounter++;\n      }\n    }\n\n    cells.map((el:Cell[]) => {\n      el.map((cell:Cell) => {\n        if(!cell.isMine){\n            let koef:number = -1;\n            let minesCounter:number = 0;\n            cell.cellsAround = [];\n            for(let i = 0; i < 3; i++){\n              if(cells[cell.pos.row - 1] && cells[cell.pos.row - 1][cell.pos.col + koef]){\n                cell.cellsAround.push(cells[cell.pos.row - 1][cell.pos.col + koef])\n                if(cells[cell.pos.row - 1][cell.pos.col + koef].isMine){\n                  minesCounter++;\n                }\n              }\n              if(cells[cell.pos.row + 1] && cells[cell.pos.row + 1][cell.pos.col + koef]){\n                cell.cellsAround.push(cells[cell.pos.row + 1] && cells[cell.pos.row + 1][cell.pos.col + koef]);\n                if(cells[cell.pos.row + 1][cell.pos.col + koef].isMine){\n                  minesCounter++;\n                }\n              }\n              koef++;\n            }\n            koef = -1;\n            for(let i = 0; i < 2; i++){\n              if(cells[cell.pos.row][cell.pos.col + koef]){\n                cell.cellsAround.push(cells[cell.pos.row][cell.pos.col + koef])\n                if(cells[cell.pos.row][cell.pos.col + koef].isMine){\n                  minesCounter++;\n                }\n              }\n              koef = 1;\n            }\n            cell.minesAround = minesCounter;\n        }\n      })\n    })\n\n    this.setState({cells: cells, result: {isWin: this.state.result.isWin, open: false}});   \n  }\n\n  componentDidMount():void {\n    const {\n      minesMount,\n      cellsMount\n    } = this.state;\n\n    \n    const arr:number[] = _.shuffle(_.range(cellsMount.row * cellsMount.col));\n    const minesCells:number[] = _.range(minesMount).map( (el:number) => arr[el] );\n\n    // let cells:Cell[][] = [];\n    let cells:Cell[][] = new Array<Array<Cell>>();\n    let cellCounter = 0;\n    for(let i = 0; i < cellsMount.row; i++){\n      // cells.push([]);\n      cells[i] = new Array<Cell>();\n      for(let j = 0; j < cellsMount.col; j++){\n        const cell = {\n          id: cellCounter,\n          pos: {\n            row: i,\n            col: j\n          },\n          isMine: minesCells.includes(cellCounter),\n          cellsAround: null,\n          minesAround: null,\n          state: 'close',\n        }\n        cells[i].push(cell);\n        cellCounter++;\n      }\n    }\n\n    cells.map((el:Cell[]) => {\n      el.map((cell:Cell) => {\n        if(!cell.isMine){\n            let koef:number = -1;\n            let minesCounter:number = 0;\n            cell.cellsAround = [];\n            for(let i = 0; i < 3; i++){\n              if(cells[cell.pos.row - 1] && cells[cell.pos.row - 1][cell.pos.col + koef]){\n                cell.cellsAround.push(cells[cell.pos.row - 1][cell.pos.col + koef])\n                if(cells[cell.pos.row - 1][cell.pos.col + koef].isMine){\n                  minesCounter++;\n                }\n              }\n              if(cells[cell.pos.row + 1] && cells[cell.pos.row + 1][cell.pos.col + koef]){\n                cell.cellsAround.push(cells[cell.pos.row + 1] && cells[cell.pos.row + 1][cell.pos.col + koef]);\n                if(cells[cell.pos.row + 1][cell.pos.col + koef].isMine){\n                  minesCounter++;\n                }\n              }\n              koef++;\n            }\n            koef = -1;\n            for(let i = 0; i < 2; i++){\n              if(cells[cell.pos.row][cell.pos.col + koef]){\n                cell.cellsAround.push(cells[cell.pos.row][cell.pos.col + koef])\n                if(cells[cell.pos.row][cell.pos.col + koef].isMine){\n                  minesCounter++;\n                }\n              }\n              koef = 1;\n            }\n            cell.minesAround = minesCounter;\n        }\n      })\n    })\n\n    this.setState({cells: cells});\n  }\n}\n\nexport default App;\n"]},"metadata":{},"sourceType":"module"}