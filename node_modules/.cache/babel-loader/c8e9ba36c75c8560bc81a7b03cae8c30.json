{"ast":null,"code":"var _jsxFileName = \"/home/nick/minesweeper_ts/src/App.tsx\";\nimport React, { Component } from 'react';\nimport './App.css';\n\nconst _ = require('underscore');\n\nclass App extends Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      cellsMount: {\n        row: 8,\n        col: 10\n      },\n      minesMount: 10,\n      result: {\n        isWin: false,\n        open: false\n      },\n      winTitles: ['YOU WIN!', 'GAME OVER'],\n      cells: new Array()\n    };\n    this.openCell = this.openCell.bind(this);\n    this.markCell = this.markCell.bind(this);\n    this.restart = this.restart.bind(this);\n  }\n\n  openCell(pos) {\n    console.log('isWin', this.state.result.isWin);\n    const updatedCells = this.state.cells.map(el => el);\n\n    if (updatedCells[pos.row][pos.col].state !== 'mark') {\n      updatedCells[pos.row][pos.col].state = 'open';\n\n      if (updatedCells[pos.row][pos.col].isMine) {\n        updatedCells.map(el => {\n          el.map(cell => {\n            if (cell.isMine) {\n              cell.state = 'open mine inactive';\n            } else {\n              cell.state = \"\".concat(cell.state, \" inactive\");\n            }\n          });\n        });\n      } else {\n        const openedEmpty = [];\n\n        for (let i = 0; i < updatedCells.length; i++) {\n          for (let j = 0; j < updatedCells[i].length; j++) {\n            if (updatedCells[i][j].cellsAround && updatedCells[i][j].minesAround === 0 && updatedCells[i][j].state === 'open' && !openedEmpty.includes(updatedCells[i][j].id)) {\n              updatedCells[i][j].cellsAround.map(cell => {\n                cell.state = 'open';\n              });\n              openedEmpty.push(updatedCells[i][j].id);\n              i = 0;\n              j = 0;\n            }\n          }\n        }\n      }\n\n      this.setState({\n        cells: updatedCells\n      });\n      this.checkResult('open', updatedCells);\n    }\n  }\n\n  markCell(pos) {\n    const updatedCells = this.state.cells.map(el => el);\n\n    if (updatedCells[pos.row][pos.col].state === 'close') {\n      updatedCells[pos.row][pos.col].state = 'mark';\n    } else if (updatedCells[pos.row][pos.col].state === 'mark') {\n      updatedCells[pos.row][pos.col].state = 'close';\n    }\n\n    this.setState({\n      cells: updatedCells\n    });\n    this.checkResult('mark', updatedCells);\n  }\n\n  checkResult(action, updatedCells) {\n    if (action === 'mark') {\n      let rightMarked = 0;\n      let wrongMarked = 0;\n      updatedCells.map(el => {\n        el.map(cell => {\n          if (cell.state === 'mark') {\n            if (cell.isMine) {\n              rightMarked++;\n            } else {\n              wrongMarked++;\n            }\n          }\n        });\n      });\n      const isWin = rightMarked === this.state.minesMount && !wrongMarked ? true : false;\n\n      if (isWin) {\n        updatedCells.map(el => {\n          el.map(cell => {\n            cell.state = cell.state + ' inactive';\n          });\n        });\n      }\n\n      if (isWin) {\n        this.setState({\n          cells: updatedCells,\n          result: {\n            isWin,\n            open: true\n          }\n        });\n      }\n    }\n\n    if (action === 'open') {\n      let isWin = true;\n      updatedCells.map(el => {\n        el.map(cell => {\n          if (cell.state === 'open mine inactive') {\n            isWin = false;\n          }\n        });\n      });\n\n      if (!isWin) {\n        this.setState({\n          result: {\n            isWin,\n            open: true\n          }\n        });\n      }\n    }\n  }\n\n  restart() {\n    const _this$state = this.state,\n          minesMount = _this$state.minesMount,\n          cellsMount = _this$state.cellsMount;\n\n    const arr = _.shuffle(_.range(cellsMount.row * cellsMount.col));\n\n    const minesCells = _.range(minesMount).map(el => arr[el]);\n\n    let cells = new Array();\n    let cellCounter = 0;\n\n    for (let i = 0; i < cellsMount.row; i++) {\n      cells[i] = new Array();\n\n      for (let j = 0; j < cellsMount.col; j++) {\n        const cell = {\n          id: cellCounter,\n          pos: {\n            row: i,\n            col: j\n          },\n          isMine: minesCells.includes(cellCounter),\n          cellsAround: new Array(),\n          minesAround: null,\n          state: 'close'\n        };\n        cells[i].push(cell);\n        cellCounter++;\n      }\n    }\n\n    cells.map(el => {\n      el.map(cell => {\n        if (!cell.isMine) {\n          let koef = -1;\n          let minesCounter = 0;\n\n          for (let i = 0; i < 3; i++) {\n            if (cells[cell.pos.row - 1] && cells[cell.pos.row - 1][cell.pos.col + koef]) {\n              cell.cellsAround.push(cells[cell.pos.row - 1][cell.pos.col + koef]);\n\n              if (cells[cell.pos.row - 1][cell.pos.col + koef].isMine) {\n                minesCounter++;\n              }\n            }\n\n            if (cells[cell.pos.row + 1] && cells[cell.pos.row + 1][cell.pos.col + koef]) {\n              cell.cellsAround.push(cells[cell.pos.row + 1] && cells[cell.pos.row + 1][cell.pos.col + koef]);\n\n              if (cells[cell.pos.row + 1][cell.pos.col + koef].isMine) {\n                minesCounter++;\n              }\n            }\n\n            koef++;\n          }\n\n          koef = -1;\n\n          for (let i = 0; i < 2; i++) {\n            if (cells[cell.pos.row][cell.pos.col + koef]) {\n              cell.cellsAround.push(cells[cell.pos.row][cell.pos.col + koef]);\n\n              if (cells[cell.pos.row][cell.pos.col + koef].isMine) {\n                minesCounter++;\n              }\n            }\n\n            koef = 1;\n          }\n\n          cell.minesAround = minesCounter;\n        }\n      });\n    });\n    this.setState({\n      cells: cells,\n      result: {\n        isWin: this.state.result.isWin,\n        open: false\n      }\n    });\n  }\n\n  componentDidMount() {\n    const _this$state2 = this.state,\n          minesMount = _this$state2.minesMount,\n          cellsMount = _this$state2.cellsMount;\n\n    const arr = _.shuffle(_.range(cellsMount.row * cellsMount.col));\n\n    const minesCells = _.range(minesMount).map(el => arr[el]);\n\n    let cells = new Array();\n    let cellCounter = 0;\n\n    for (let i = 0; i < cellsMount.row; i++) {\n      cells[i] = new Array();\n\n      for (let j = 0; j < cellsMount.col; j++) {\n        const cell = {\n          id: cellCounter,\n          pos: {\n            row: i,\n            col: j\n          },\n          isMine: minesCells.includes(cellCounter),\n          cellsAround: new Array(),\n          minesAround: null,\n          state: 'close'\n        };\n        cells[i].push(cell);\n        cellCounter++;\n      }\n    }\n\n    cells.map(el => {\n      el.map(cell => {\n        if (!cell.isMine) {\n          let koef = -1;\n          let minesCounter = 0;\n\n          for (let i = 0; i < 3; i++) {\n            if (cells[cell.pos.row - 1] && cells[cell.pos.row - 1][cell.pos.col + koef]) {\n              cell.cellsAround.push(cells[cell.pos.row - 1][cell.pos.col + koef]);\n\n              if (cells[cell.pos.row - 1][cell.pos.col + koef].isMine) {\n                minesCounter++;\n              }\n            }\n\n            if (cells[cell.pos.row + 1] && cells[cell.pos.row + 1][cell.pos.col + koef]) {\n              cell.cellsAround.push(cells[cell.pos.row + 1] && cells[cell.pos.row + 1][cell.pos.col + koef]);\n\n              if (cells[cell.pos.row + 1][cell.pos.col + koef].isMine) {\n                minesCounter++;\n              }\n            }\n\n            koef++;\n          }\n\n          koef = -1;\n\n          for (let i = 0; i < 2; i++) {\n            if (cells[cell.pos.row][cell.pos.col + koef]) {\n              cell.cellsAround.push(cells[cell.pos.row][cell.pos.col + koef]);\n\n              if (cells[cell.pos.row][cell.pos.col + koef].isMine) {\n                minesCounter++;\n              }\n            }\n\n            koef = 1;\n          }\n\n          cell.minesAround = minesCounter;\n        }\n      });\n    });\n    this.setState({\n      cells: cells\n    });\n  }\n\n  render() {\n    const _this$state3 = this.state,\n          result = _this$state3.result,\n          cells = _this$state3.cells;\n    return React.createElement(\"div\", {\n      className: \"App\",\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 296\n      },\n      __self: this\n    }, React.createElement(Result, {\n      result: result,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 297\n      },\n      __self: this\n    }), React.createElement(\"div\", {\n      className: \"tableCells\",\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 300\n      },\n      __self: this\n    }, React.createElement(TableCells, {\n      cells: cells,\n      openCell: this.openCell,\n      markCell: this.markCell,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 301\n      },\n      __self: this\n    }), React.createElement(Button, {\n      onClick: this.restart,\n      children: 'restart',\n      className: 'button-restart',\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 306\n      },\n      __self: this\n    })));\n  }\n\n}\n\nconst TableCells = ({\n  cells,\n  openCell,\n  markCell\n}) => {\n  let tableCells = cells.map((el, i) => {\n    let cellsArr = el.map((cell, j) => {\n      let content = null;\n\n      if (cell.isMine) {\n        content = '*';\n      } else if (cell.minesAround) {\n        content = \"\".concat(cell.minesAround);\n      }\n\n      return React.createElement(\"div\", {\n        className: \"cell \".concat(cell.state),\n        key: \"cell-\".concat(cell.id),\n        onClick: () => openCell(cell.pos),\n        onContextMenu: e => {\n          e.preventDefault();\n          return markCell(cell.pos);\n        },\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 337\n        },\n        __self: this\n      }, React.createElement(\"div\", {\n        className: \"value\",\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 346\n        },\n        __self: this\n      }, content));\n    });\n    return React.createElement(\"div\", {\n      className: \"cellsRow\",\n      key: \"cellsRow-\".concat(i),\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 353\n      },\n      __self: this\n    }, cellsArr);\n  });\n  return React.createElement(React.Fragment, null, tableCells);\n};\n\nconst Button = ({\n  onClick,\n  className = '',\n  children\n}) => React.createElement(\"button\", {\n  onClick: onClick,\n  className: className,\n  type: \"button\",\n  __source: {\n    fileName: _jsxFileName,\n    lineNumber: 366\n  },\n  __self: this\n}, children);\n\nconst Result = ({\n  result\n}) => {\n  let title = result.isWin ? 'YOU WIN!' : 'GAME OVER';\n  let titleState = result.open ? 'result open' : 'result close';\n  return React.createElement(\"div\", {\n    className: titleState,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 382\n    },\n    __self: this\n  }, title);\n};\n\nexport default App;","map":{"version":3,"sources":["/home/nick/minesweeper_ts/src/App.tsx"],"names":["React","Component","_","require","App","constructor","props","state","cellsMount","row","col","minesMount","result","isWin","open","winTitles","cells","Array","openCell","bind","markCell","restart","pos","console","log","updatedCells","map","el","isMine","cell","openedEmpty","i","length","j","cellsAround","minesAround","includes","id","push","setState","checkResult","action","rightMarked","wrongMarked","arr","shuffle","range","minesCells","cellCounter","koef","minesCounter","componentDidMount","render","TableCells","tableCells","cellsArr","content","e","preventDefault","Button","onClick","className","children","Result","title","titleState"],"mappings":"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","sourcesContent":["import React, {Component} from 'react';\nimport './App.css';\nconst _:any = require('underscore')\n\ninterface Pos{\n  row: number,\n  col: number\n}\ninterface Cell{ \n  id: number,\n  pos: {\n    row: number,\n    col: number\n  },\n  isMine: boolean,\n  cellsAround: Cell[],\n  minesAround: null | number,\n  state: string,\n}\n\ninterface State{\n  cellsMount: {\n    row: number,\n    col: number,\n  },\n  minesMount: number,\n  result: {isWin: boolean, open: boolean},\n  winTitles: [string, string],\n  cells: Cell[][]\n}\n\nclass App extends Component<any, State> {\n  constructor(props:any) {\n    super(props);\n    this.state = {\n      cellsMount: {\n        row: 8,\n        col: 10,\n      },\n      minesMount: 10,\n      result: {isWin: false, open: false},\n      winTitles: ['YOU WIN!', 'GAME OVER'],\n      cells: new Array<Array<Cell>>()\n    };\n\n    this.openCell = this.openCell.bind(this)\n    this.markCell = this.markCell.bind(this)\n    this.restart = this.restart.bind(this)\n  }\n\n  openCell(pos: Pos):void {\n    console.log('isWin',this.state.result.isWin)\n    const updatedCells = this.state.cells.map( (el: Cell[]) => el);\n\n    if(updatedCells[pos.row][pos.col].state !== 'mark'){\n      updatedCells[pos.row][pos.col].state = 'open';\n\n      if(updatedCells[pos.row][pos.col].isMine){\n        updatedCells.map( (el: Cell[]) => {\n          el.map( (cell: Cell) => {\n            if(cell.isMine){\n              cell.state = 'open mine inactive'\n            }else{\n              cell.state = `${cell.state} inactive`\n            }\n          })\n        })\n      }else{\n        const openedEmpty:number[]  = [];\n        for(let i = 0; i < updatedCells.length; i++){\n          for(let j = 0; j < updatedCells[i].length; j++){\n            if(updatedCells[i][j].cellsAround \n              && updatedCells[i][j].minesAround === 0 \n              && updatedCells[i][j].state === 'open' \n              && !openedEmpty.includes(updatedCells[i][j].id)){\n                updatedCells[i][j].cellsAround.map( (cell: Cell) => {\n                  cell.state = 'open';\n                })\n                openedEmpty.push(updatedCells[i][j].id);\n                i = 0;\n                j = 0;\n            }\n          }\n        }\n      }\n\n      this.setState({cells: updatedCells});\n      this.checkResult('open',updatedCells);\n    }\n  }\n\n  markCell(pos: Pos):void {\n    const updatedCells = this.state.cells.map( (el: Cell[]) => el);\n\n    if(updatedCells[pos.row][pos.col].state === 'close'){\n      updatedCells[pos.row][pos.col].state = 'mark';\n    }else if(updatedCells[pos.row][pos.col].state === 'mark'){\n      updatedCells[pos.row][pos.col].state = 'close'\n    }\n\n    this.setState({cells: updatedCells});\n    this.checkResult('mark',updatedCells);\n  }\n\n  checkResult(action: string, updatedCells: Cell[][]):void {\n    if(action === 'mark'){\n      let rightMarked = 0;\n      let wrongMarked = 0;\n      updatedCells.map( (el: Cell[]) => {\n        el.map( (cell: Cell) => {\n          if(cell.state === 'mark'){\n            if(cell.isMine){\n              rightMarked++;\n            }else{\n              wrongMarked++;\n            }\n          }\n        })\n      });\n\n      const isWin:boolean = (rightMarked === this.state.minesMount && !wrongMarked) ? true : false\n\n      if(isWin){\n        updatedCells.map( (el: Cell[]) => {\n          el.map( (cell: Cell) => {\n            cell.state = cell.state + ' inactive'\n          })\n        })\n      }\n\n      if(isWin){\n        this.setState({cells: updatedCells, result: {isWin, open: true}})\n      }\n    }\n    if(action === 'open'){\n      let isWin:boolean = true;\n      updatedCells.map( (el: Cell[]) => {\n        el.map( (cell: Cell) => {\n          if(cell.state === 'open mine inactive'){\n            isWin = false\n          }\n        })\n      })\n\n      if(!isWin){\n        this.setState({result: {isWin, open: true}})\n      }\n    }\n  }\n\n  restart():void {\n    const {\n      minesMount,\n      cellsMount,\n    } = this.state;\n\n    \n    const arr:number[] = _.shuffle(_.range(cellsMount.row * cellsMount.col));\n    const minesCells:number[] = _.range(minesMount).map( (el:number) => arr[el] );\n\n    let cells:Cell[][] = new Array<Array<Cell>>();\n    let cellCounter:number = 0;\n    for(let i = 0; i < cellsMount.row; i++){\n      cells[i] = new Array<Cell>();\n      for(let j = 0; j < cellsMount.col; j++){\n        const cell:Cell = {\n          id: cellCounter,\n          pos: {\n            row: i,\n            col: j\n          },\n          isMine: minesCells.includes(cellCounter),\n          cellsAround: new Array<Cell>(),\n          minesAround: null,\n          state: 'close',\n        }\n        cells[i].push(cell);\n        cellCounter++;\n      }\n    }\n\n    cells.map((el:Cell[]) => {\n      el.map((cell:Cell) => {\n        if(!cell.isMine){\n            let koef:number = -1;\n            let minesCounter:number = 0;\n            for(let i = 0; i < 3; i++){\n              if(cells[cell.pos.row - 1] && cells[cell.pos.row - 1][cell.pos.col + koef]){\n                cell.cellsAround.push(cells[cell.pos.row - 1][cell.pos.col + koef])\n                if(cells[cell.pos.row - 1][cell.pos.col + koef].isMine){\n                  minesCounter++;\n                }\n              }\n              if(cells[cell.pos.row + 1] && cells[cell.pos.row + 1][cell.pos.col + koef]){\n                cell.cellsAround.push(cells[cell.pos.row + 1] && cells[cell.pos.row + 1][cell.pos.col + koef]);\n                if(cells[cell.pos.row + 1][cell.pos.col + koef].isMine){\n                  minesCounter++;\n                }\n              }\n              koef++;\n            }\n            koef = -1;\n            for(let i = 0; i < 2; i++){\n              if(cells[cell.pos.row][cell.pos.col + koef]){\n                cell.cellsAround.push(cells[cell.pos.row][cell.pos.col + koef])\n                if(cells[cell.pos.row][cell.pos.col + koef].isMine){\n                  minesCounter++;\n                }\n              }\n              koef = 1;\n            }\n            cell.minesAround = minesCounter;\n        }\n      })\n    })\n\n    this.setState({cells: cells, result: {isWin: this.state.result.isWin, open: false}});   \n  }\n\n  componentDidMount():void {\n    const {\n      minesMount,\n      cellsMount\n    } = this.state;\n\n    \n    const arr:number[] = _.shuffle(_.range(cellsMount.row * cellsMount.col));\n    const minesCells:number[] = _.range(minesMount).map( (el:number) => arr[el] );\n\n    let cells:Cell[][] = new Array<Array<Cell>>();\n    let cellCounter = 0;\n    for(let i = 0; i < cellsMount.row; i++){\n      cells[i] = new Array<Cell>();\n      for(let j = 0; j < cellsMount.col; j++){\n        const cell = {\n          id: cellCounter,\n          pos: {\n            row: i,\n            col: j\n          },\n          isMine: minesCells.includes(cellCounter),\n          cellsAround: new Array<Cell>(),\n          minesAround: null,\n          state: 'close',\n        }\n        cells[i].push(cell);\n        cellCounter++;\n      }\n    }\n\n    cells.map((el:Cell[]) => {\n      el.map((cell:Cell) => {\n        if(!cell.isMine){\n          let koef:number = -1;\n          let minesCounter:number = 0;\n          for(let i = 0; i < 3; i++){\n            if(cells[cell.pos.row - 1] && cells[cell.pos.row - 1][cell.pos.col + koef]){\n              cell.cellsAround.push(cells[cell.pos.row - 1][cell.pos.col + koef])\n              if(cells[cell.pos.row - 1][cell.pos.col + koef].isMine){\n                minesCounter++;\n              }\n            }\n            if(cells[cell.pos.row + 1] && cells[cell.pos.row + 1][cell.pos.col + koef]){\n              cell.cellsAround.push(cells[cell.pos.row + 1] && cells[cell.pos.row + 1][cell.pos.col + koef]);\n              if(cells[cell.pos.row + 1][cell.pos.col + koef].isMine){\n                minesCounter++;\n              }\n            }\n            koef++;\n          }\n          koef = -1;\n          for(let i = 0; i < 2; i++){\n            if(cells[cell.pos.row][cell.pos.col + koef]){\n              cell.cellsAround.push(cells[cell.pos.row][cell.pos.col + koef])\n              if(cells[cell.pos.row][cell.pos.col + koef].isMine){\n                minesCounter++;\n              }\n            }\n            koef = 1;\n          }\n          cell.minesAround = minesCounter;\n        }\n      })\n    })\n\n    this.setState({cells: cells});\n  }\n\n  render() {\n    const {\n      result,\n      cells\n    } = this.state;\n\n    return (\n      <div className=\"App\">\n        <Result\n          result = {result}\n        />\n        <div className = 'tableCells'>\n        <TableCells \n          cells = {cells}\n          openCell = {this.openCell}\n          markCell = {this.markCell}\n        />\n        <Button \n          onClick = {this.restart}\n          children = {'restart'}\n          className = {'button-restart'}\n        />\n        </div>\n      </div>\n    );\n  }\n}\n\ninterface TableCellsProps {\n  cells: Cell[][],\n  openCell:(pos:Pos) => void,\n  markCell:(pos:Pos) => void\n}\n\nconst TableCells = ({\n  cells,\n  openCell,\n  markCell\n}:TableCellsProps) => {\n  let tableCells = cells.map((el:Cell[], i:number) => {\n      let cellsArr = el.map((cell:Cell, j:number) => {\n        let content:string | null = null;\n        if(cell.isMine){\n          content = '*'\n        }else if(cell.minesAround){\n          content = `${cell.minesAround}`\n        }\n          return  (\n            <div \n              className = {`cell ${cell.state}`}\n              key = {`cell-${cell.id}`}\n              onClick = { () => openCell(cell.pos)}\n              onContextMenu = { (e:React.MouseEvent) => {\n                e.preventDefault();\n                return markCell(cell.pos);\n              }}\n            >\n              <div className = 'value'>\n                {content}\n              </div>\n            </div>\n            )\n      });\n      return (\n        <div className = 'cellsRow' key={`cellsRow-${i}`}>{cellsArr}</div>\n        )\n    })\n    return (<>{tableCells}</>)\n}\n\ninterface ButtonProps{\n  onClick:(e:React.MouseEvent) => void,\n  className: string,\n  children: React.ReactNode\n}\n\nconst Button = ({ onClick, className = '', children }:ButtonProps) =>\n  <button\n    onClick={onClick}\n    className={className}\n    type=\"button\"\n  >\n    {children}\n  </button>\n\n\ninterface ResultProps{\n  result: {isWin: null | boolean, open: boolean}\n}\nconst Result = ({result}:ResultProps) =>{\n  let title:string = result.isWin ? 'YOU WIN!' : 'GAME OVER';\n  let titleState:string = result.open ? 'result open' : 'result close';\n  return (\n    <div\n      className = {titleState}\n    >{title}</div>\n    )\n}\n\nexport default App;\n"]},"metadata":{},"sourceType":"module"}